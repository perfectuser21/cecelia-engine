# Step 09.5 - Pending Wait

> 等待 CI 结果的循环逻辑

---

## 适用场景

当用户说"继续"时，如果阶段检测输出 `PHASE: pending`，应该进入等待循环。

---

## 核心逻辑

```bash
# 1. 获取 PR 号
PR_NUMBER=$(gh pr list --head "$(git rev-parse --abbrev-ref HEAD)" --state open --json number -q '.[0].number')

if [[ -z "$PR_NUMBER" ]]; then
    echo "❌ 无法找到 PR，请先创建 PR"
    exit 1
fi

# 2. 进入等待循环
MAX_WAIT_TIME=$((60 * 60))  # 1 小时超时
START_TIME=$(date +%s)

while true; do
    # 检查超时
    CURRENT_TIME=$(date +%s)
    ELAPSED=$((CURRENT_TIME - START_TIME))

    if [[ $ELAPSED -gt $MAX_WAIT_TIME ]]; then
        echo "⏰ 等待超时（1小时），请手动检查 CI 状态"
        exit 1
    fi

    # 获取 CI 状态
    CI_STATUS=$(gh pr checks "$PR_NUMBER" --json state -q '.[].state' 2>/dev/null | head -1 || echo "")

    echo "⏳ CI 状态: $CI_STATUS"

    case "$CI_STATUS" in
        "PENDING"|"QUEUED"|"")
            echo "⏳ CI 尚未完成，等待 30 秒..."
            sleep 30
            continue
            ;;

        *FAILURE*|*ERROR*)
            echo "❌ CI 失败，转入 p1 修复流程"
            # 重新运行阶段检测，会进入 p1
            bash scripts/detect-phase.sh
            exit 0
            ;;

        *SUCCESS*|*PASS*)
            echo "✅ CI 通过，转入 p2 结束流程"
            # 重新运行阶段检测，会进入 p2
            bash scripts/detect-phase.sh
            exit 0
            ;;

        *)
            echo "⚠️  未知 CI 状态: $CI_STATUS"
            sleep 30
            continue
            ;;
    esac
done
```

---

## 两阶段分离的正确含义

**误解** ❌：
- pending 是"中间态"，应该退出
- 用户说"继续"时，检测到 pending 就直接退出

**正确理解** ✅：
- p0 阶段：创建 PR → **退出会话**（不等 CI）
- **新会话**：用户说"继续" → 检测阶段 → pending → **挂着等 CI 出结果**
- p1 阶段：CI fail → 修复 → push → **退出会话**

**关键点**：
- "两阶段分离"指的是 **阶段之间退出会话**（p0 → 新会话 → p1/p2）
- 但在**同一会话内**，pending 应该进入等待循环，直到 CI 有结果
- 不是"每个状态都退出"，而是"阶段完成后退出"

---

## 进度提示

等待过程中应该给用户清晰的提示：

```
开始等待 CI 结果...
⏳ CI 状态: PENDING
⏳ CI 尚未完成，等待 30 秒...
⏳ CI 状态: PENDING
⏳ CI 尚未完成，等待 30 秒...
...
✅ CI 通过，转入 p2 结束流程
```

---

## 超时保护

- 最大等待时间：1 小时
- 超时后退出，提示用户手动检查
- 避免无限等待

---

## 与 p1 的区别

| 阶段 | 触发条件 | 行为 |
|------|----------|------|
| **pending** | CI 运行中（PENDING/QUEUED） | 等待循环，直到有结果 |
| **p1** | CI 失败（FAILURE/ERROR） | 修复循环，修复 → push → 等待 → 检查 |

**关系**：
- pending → CI fail → 转入 p1
- p1 → 修复 push → 可能再次进入 pending → 再等待

---

## 实现方式

**方式 1**：在 Step 09.5 中实现完整逻辑（推荐）
- 独立的等待循环脚本
- 超时保护
- 清晰的进度提示

**方式 2**：在 detect-phase.sh 中直接等待
- 简化流程
- 但会让阶段检测脚本变复杂

**推荐方式 1**，保持阶段检测的简洁性。

---

## 调用示例

```bash
# 用户说"继续"
# 1. 运行阶段检测
bash scripts/detect-phase.sh

# 输出: PHASE: pending

# 2. 进入等待循环
bash skills/dev/steps/09.5-pending-wait.sh

# 3. 等待 CI 结果
# - CI 成功 → 转入 p2
# - CI 失败 → 转入 p1
```

---

## 注意事项

1. **不要在 p0 阶段等待 CI**
   - p0 创建 PR 后应该直接退出
   - 不等待 CI 结果

2. **pending 等待是在新会话中**
   - 用户说"继续"启动新会话
   - 阶段检测发现 pending
   - 进入等待循环

3. **超时保护必须有**
   - 避免 CI 卡住导致无限等待
   - 1 小时超时，提示用户手动检查

4. **清晰的进度提示**
   - 用户能看到等待进度
   - 知道 CI 当前状态
   - 明确下一步动作
