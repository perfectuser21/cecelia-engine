# Step 9: CI 修复（p1 阶段）

> p1 阶段：事件驱动循环，修复 → push → 退出
> **在 P1 阶段只做一轮修复，push 后退出，等下次 CI 失败通知唤醒**

---

## 阶段定义

**p1 阶段触发条件**：
- PR 已创建
- CI 状态为 FAILURE

**p1 阶段目标**：
- 拉取 CI 失败详情
- 分析并修复问题
- push 代码后退出（不等 CI 结果）

---

## p1 事件驱动循环

```
┌─────────────────────────────────────────────────────┐
│          p1: CI fail 修复（事件驱动）                │
├─────────────────────────────────────────────────────┤
│                                                     │
│  阶段检测 (scripts/detect-phase.sh)                 │
│      → PHASE: p1                                    │
│      ↓                                              │
│  CI 修复流程 (09-ci.md)                             │
│      │                                              │
│      │   1. 拉取 CI 失败详情                        │
│      │      gh pr checks <PR> --json ...            │
│      │                                              │
│      │   2. 分析失败原因                            │
│      │      (typecheck/test/build)                  │
│      │                                              │
│      │   3. 修复代码                                │
│      │                                              │
│      │   4. push 代码                               │
│      │      git add . && git commit && git push     │
│      │                                              │
│      │   5. 尝试结束对话                            │
│      │      Stop Hook 检查:                         │
│      │        CI fail → exit 2（继续修）            │
│      │        CI pending → exit 0（退出，等唤醒）   │
│      │        CI pass → exit 0（结束）              │
│      │                                              │
│      ↓                                              │
│  结束对话 ✅ （等下次唤醒）                          │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## Stop Hook 行为（p1）

**检查逻辑**：

```bash
# 1. 检测阶段
PHASE=$(bash scripts/detect-phase.sh | grep "^PHASE:" | awk '{print $2}')

# 2. p1 阶段检查 CI 状态
if [[ "$PHASE" == "p1" ]]; then
    CI_STATUS=$(gh pr checks "$PR_NUMBER" --json state -q '.[].state' | head -1)

    if [[ "$CI_STATUS" == "PENDING" ]]; then
        # CI pending: 退出，等下次唤醒
        exit 0

    elif echo "$CI_STATUS" | grep -qi "FAILURE"; then
        # CI fail: 阻止结束，继续修复
        echo "CI 失败，需要修复"
        echo "运行: gh pr checks $PR_NUMBER"
        exit 2  # 阻止会话结束

    elif echo "$CI_STATUS" | grep -qi "SUCCESS"; then
        # CI pass: 允许结束
        exit 0
    fi
fi
```

---

## 修复流程实现

**完整修复逻辑**：

```bash
# 获取 PR 编号
PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number -q '.[0].number')

# 1. 拉取 CI 失败详情
echo "📊 拉取 CI 失败详情..."
CI_DATA=$(gh pr checks "$PR_NUMBER" --json state,conclusion,name 2>/dev/null)

if [ -z "$CI_DATA" ]; then
    echo "❌ 无法获取 CI 详情"
    exit 1
fi

# 2. 解析失败检查
FAILED_CHECK=$(echo "$CI_DATA" | jq -r '.[] | select(.conclusion == "FAILURE") | .name' | head -1)

if [ -z "$FAILED_CHECK" ]; then
    echo "⚠️ 未找到失败的检查"
    exit 0
fi

echo "🔧 修复失败的检查: $FAILED_CHECK"

# 3. 根据失败类型修复
if echo "$FAILED_CHECK" | grep -qi "typecheck"; then
    echo "修复类型检查错误..."
    npm run typecheck 2>&1 || true
    # 分析错误并修复代码...

elif echo "$FAILED_CHECK" | grep -qi "test"; then
    echo "修复测试失败..."
    npm run test 2>&1 || true
    # 分析错误并修复代码...

elif echo "$FAILED_CHECK" | grep -qi "build"; then
    echo "修复构建失败..."
    npm run build 2>&1 || true
    # 分析错误并修复代码...
fi

# 4. 提交修复
git add -A
git commit -m "fix: 修复 CI 失败 ($FAILED_CHECK)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
/usr/bin/git push origin HEAD

echo "✅ 修复已推送，退出等待下次 CI 结果"

# 5. 尝试结束对话
# Stop Hook 会检查 CI 状态：
#   - CI still fail → exit 2（不允许结束，继续修）
#   - CI pending → exit 0（允许结束，等下次唤醒）
#   - CI pass → exit 0（允许结束）
```

---

## 事件驱动 vs 轮询循环

**✅ 正确模式（事件驱动）**：
```bash
# 1. 修复代码
fix_code()

# 2. push 触发 CI
git push

# 3. 退出对话（不等 CI）
# Stop Hook: CI pending → exit 0

# 4. 等待外部唤醒
#    - CI fail 通知 → PHASE_OVERRIDE=p1 启动新会话
#    - 或手动启动下次会话
```

**❌ 错误模式（轮询循环）**：
```bash
# 不要这样做！
while true; do
    CI_STATUS=$(gh pr checks "$PR_NUMBER")

    case "$CI_STATUS" in
        running)
            sleep 30
            continue  # ❌ 挂着等待
            ;;
        failure)
            fix_code
            git push
            continue  # ❌ 继续循环（不退出）
            ;;
        success)
            gh pr merge
            break
            ;;
    esac
done
```

---

## CI 失败详情获取

```bash
# 获取 PR 检查状态
gh pr checks "$PR_NUMBER" --json name,conclusion,detailsUrl

# 查看失败日志
gh pr checks "$PR_NUMBER" | grep "FAILURE" -A 5

# 查看具体 workflow run
gh run view <run-id> --log-failed
```

---

## p1 完成条件

| CI 状态 | Stop Hook 行为 | 说明 |
|---------|---------------|------|
| FAILURE | exit 2 | 阻止结束，继续修复 |
| PENDING | exit 0 | 允许结束，等下次唤醒 |
| SUCCESS | exit 0 | 允许结束，GitHub 自动 merge |

---

## p2 阶段（CI pass）

**自动进入条件**：
- PR 存在
- CI 状态为 SUCCESS

**行为**：
- Stop Hook 检测到 PHASE=p2
- 直接 `exit 0` 允许结束
- GitHub 自动合并 PR
- 进入 Learning/Cleanup（Step 10/11）

---

## 合并逻辑

**CI 通过后合并**：
- GitHub Actions 自动合并（配置了 auto-merge）
- 不需要手动运行 `gh pr merge`
- 自动删除功能分支（GitHub 设置）

---

## 注意事项

1. **事件驱动**：push 后退出，不挂着等 CI
2. **一轮修复**：每次会话只做一轮修复，不循环
3. **Stop Hook 控制**：是否结束由 Stop Hook 决定
4. **两阶段分离**：p0 不检查 CI，p1 修复后立即退出
