# Step 09.5 - CI 处理循环（p1/pending/p2）

> **⚡ 核心认知**：p1/pending/p2 是同一个持续循环的不同状态，应该一直运行直到 PR 合并

---

## 适用场景

当阶段检测输出 `PHASE: p1` 或 `PHASE: pending` 时，进入 CI 处理循环。

---

## ⚡ CI 处理循环（持续运行到合并）

**核心逻辑**：

```bash
# 获取 PR 号
PR_NUMBER=$(gh pr list --head "$(git branch --show-current)" --state open --json number -q '.[0].number')

if [[ -z "$PR_NUMBER" ]]; then
  echo "错误：未找到当前分支的 PR"
  exit 1
fi

echo "开始 CI 处理循环（PR #${PR_NUMBER}）"
echo "将持续运行直到 PR 合并..."
echo ""

# 持续循环直到 CI 通过并合并
while true; do
  # 检查 CI 状态
  CI_STATUS=$(gh pr checks "$PR_NUMBER" --json state -q '.[].state' 2>/dev/null | head -1)

  case "$CI_STATUS" in
    FAILURE|ERROR)
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo "  ❌ CI 失败"
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo ""

      # 查看失败详情
      echo "查看失败详情..."
      gh pr checks "$PR_NUMBER"
      echo ""

      # 分析失败原因并修复
      echo "分析失败原因..."
      # AI 会在这里分析 CI 日志并修复代码

      # 修复代码后提交
      git add .
      git commit -m "fix: CI failure"
      git push

      echo ""
      echo "已推送修复，等待 30 秒后继续检查..."
      sleep 30
      continue  # 继续循环
      ;;

    PENDING|QUEUED|IN_PROGRESS|WAITING)
      echo "⏳ CI 运行中（状态: ${CI_STATUS}），等待 30 秒..."
      sleep 30
      continue  # 继续循环
      ;;

    SUCCESS|PASS)
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo "  ✅ CI 全部通过"
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo ""

      # 合并 PR
      echo "合并 PR #${PR_NUMBER}..."
      gh pr merge "$PR_NUMBER" --squash --delete-branch

      echo ""
      echo "✅ PR 已合并，分支已删除"
      echo ""
      break  # 退出循环
      ;;

    *)
      echo "⚠️ 未知 CI 状态: ${CI_STATUS}"
      echo "等待 30 秒后重试..."
      sleep 30
      continue
      ;;
  esac
done

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  ✅ CI 处理循环完成"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
```

---

## 工作流程

### p0 → p1/pending/p2 完整流程

```
[p0 阶段]
用户: "修复 XXX"
/dev → 创建 PR → 结束

[CI 运行]

[p1 阶段 - 新会话]
用户: "持续查 CI"
/dev → 检测 p1 → 进入 while 循环
  ↓
  while true:
    检查 CI

    if CI fail (p1):
      ↓
      分析失败 → 修复代码 → push
      ↓
      sleep 30 → continue（继续循环）

    elif CI pending:
      ↓
      sleep 30 → continue（继续循环）

    elif CI pass (p2):
      ↓
      merge PR → break（退出循环）

  ✅ 完成
```

---

## 核心原则

1. **p0 阶段**：独立的，创建 PR 后立即结束
   - PRD → DoD → Code → Quality → PR → 结束

2. **p1/pending/p2 阶段**：是同一个持续循环
   - 进入循环 → 检查 CI → 修复/等待 → 检查 CI → 合并
   - **不退出**，直到 PR 合并

3. **不问用户**：全自动运行
   - 不输出"等待用户确认"
   - 不询问"是否继续"
   - 自动循环直到合并

---

## 与 Stop Hook 的配合

Stop Hook 在 p1/pending 阶段会阻止会话结束：

```bash
# hooks/stop.sh

PHASE=$(bash scripts/detect-phase.sh | grep "^PHASE:" | cut -d: -f2 | xargs)

if [[ "$PHASE" == "p1" ]] || [[ "$PHASE" == "pending" ]]; then
  echo "❌ 会话不能结束：有 PR 待处理"
  echo ""
  echo "⚡ Ralph Loop 自动重试机制："
  echo "  1. Hook 返回 exit 2 = 阻止会话结束"
  echo "  2. 你应该立即调用 /dev 处理 CI"
  echo "  3. /dev 将持续运行直到 PR 合并"
  echo ""
  echo "[SKILL_REQUIRED: dev]"
  exit 2  # 阻止会话结束
fi
```

---

## 超时处理

**无超时**：循环会一直运行直到 PR 合并。

- 如果 CI 运行很久（1小时+），循环会一直等待
- 这是设计如此，确保任务完成
- 适合无头模式（Cecelia）

---

## 参考

- 阶段检测：`scripts/detect-phase.sh`
- 两阶段工作流：`skills/dev/SKILL.md`
- Stop Hook：`hooks/stop.sh`
